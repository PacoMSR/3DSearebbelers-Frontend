import React, { useEffect, useRef } from "react";
import { useControls } from "leva";
import * as THREE from "three";
import { useGLTF } from "@react-three/drei";
import { extend, useFrame, useLoader, useThree } from "@react-three/fiber";

import { gestnerWave } from "./Ocean";
import boats from "./config/Boats.json";

extend({ CircleGeometry: THREE.CircleGeometry });

// used to add realism to boat (mostly shadows)
const Light = ({ position }) => {
  const ref = useRef();
  const flare = useLoader(
    THREE.TextureLoader,
    require("./data/textures/flare.png")
  );
  return (
    <>
      <pointLight ref={ref} args={["#FF4A4A", 1.5, 10]} position={position} />
      {/* flare texture to see light at night */}
      <mesh position={position} scale={0.5} rotation-x={Math.PI / 2}>
        <circleGeometry />
        <meshStandardMaterial
          color={"#FF4A4A"}
          map={flare}
          transparent
          opacity={0.7}
          side={THREE.DoubleSide}
          depthWrite={false}
        />
      </mesh>
    </>
  );
};

// https://www.movable-type.co.uk/scripts/latlong.html
export function HarvesineBearing(lat1, lon1, lat2, lon2) {
  const φ1 = (lat1 * Math.PI) / 180; // φ, λ in radians
  const φ2 = (lat2 * Math.PI) / 180;
  const Δλ = ((lon2 - lon1) * Math.PI) / 180;

  const y = Math.sin(Δλ) * Math.cos(φ2);
  const x =
    Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
  const bearing = Math.PI - Math.atan2(y, x);
  return bearing;
} // get direction from point 1 to 2

export function EquirectangularDistance(lat1, lon1, lat2, lon2) {
  const R = 6371e3; // metres
  const φ1 = (lat1 * Math.PI) / 180; // φ, λ in radians
  const φ2 = (lat2 * Math.PI) / 180;
  const Δλ = ((lon2 - lon1) * Math.PI) / 180;

  const x = Δλ * Math.cos((φ1 + φ2) / 2);
  const y = φ2 - φ1;
  const d = Math.sqrt(x * x + y * y) * R;
  return d;
} // get distance from point 1 to 2

export default function Boat({ boat, setBoat, weather }) {
  // control boat direction and mesh
  const { boatType } = useControls("Boat", {
    boatType: {
      value: "sailboat",
      options: ["sailboat", "yacht", "race boat"],
      onChange: (v) => {
        setBoat((prev) => ({
          ...prev,
          scale: boats[v].scale,
          length: boats[v].length,
        }));
      },
      transient: false,
    },
    // boatSpeed: {
    //   value: 1,
    //   min: 0,
    //   max: 4,
    //   onChange: (v) => {
    //     setBoat((prev) => ({
    //       ...prev,
    //       speed: v,
    //     }));
    //   },
    // },
  });

  const boatRef = new useRef();
  var time;

  const { scene } = useThree();
  let buoyancy = {
    normal: new THREE.Vector3(),
    position: new THREE.Vector3(),
  };
  var waves;

  const direction = HarvesineBearing(
    boat.latitude,
    boat.longitude,
    boat.next.latitude,
    boat.next.longitude
  );

  const windDirection = weather["windDirection"];
  const boatDirection = [
    -Math.sin(direction) + 0.01,
    Math.cos(direction) + 0.01, // inverted direction so it goes forward
  ]; // boat direction from angle to array

  useEffect(() => {
    setBoat((prev) => ({
      ...prev,
      // TODO - move boat forward in correct direction
      // longitude: prev.longitude + 0.00001 * boat.speed,
      // latitude: prev.latitude + 0.00001 * boat.speed,
      direction: direction,
    }));
  }, [direction, setBoat]);

  // update boat rotation
  let rot = new THREE.Vector3();
  let newRot = new THREE.Vector3();
  let boatWeight = 0.5;

  useFrame(() => {
    time = scene.getObjectByName("water").time;
    waves = scene.getObjectByName("water").waves;

    buoyancy = gestnerWave(
      waves,
      new THREE.Vector2(0, 0),
      time,
      windDirection,
      boatDirection,
      boat.speed
    );

    // update vertical position
    boatRef.current.position.setY(
      boatRef.current.position.y * boatWeight +
        buoyancy.position.y * (1 - boatWeight)
    );
    // boatRef.current.position.lerp(buoyancy.position, 1);

    // update rotation
    rot.set(
      -0.5 * buoyancy.normal.x - Math.PI / 2,
      direction,
      -0.5 * buoyancy.normal.z,
      "YZX"
    ); // ANGLE IN RADIANS IN THAT AXIS
    newRot.setFromEuler(boatRef.current.rotation).lerp(rot, 0.01);
    boatRef.current.rotation.setFromVector3(newRot, "YZX");
  });

  return (
    <group
      dispose={null}
      position={[0, 0, 0]}
      ref={boatRef}
      rotation-x={-Math.PI / 2}
      visible={true}
    >
      {boatType === "yacht" && <Yate weather={weather} />}
      {boatType === "sailboat" && <SailBoat weather={weather} />}
      {boatType === "race boat" && <RaceBoat />}
    </group>
  );
}

// DIFFERENT BOAT MODELS

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: Sergei (https://sketchfab.com/sergeif)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/3d-models/sailboat-76d0b1e24be14d2f9a524bfce3001aeb
title: Sailboat
*/

export function SailBoat({ weather }) {
  const { nodes, materials } = useGLTF("./assets/sailboat/scene.gltf"); // boat model

  return (
    <>
      {weather["skyState"] === "night" ? (
        <Light position={[0, -0.5, 7]} />
      ) : (
        <pointLight args={["#FFFFFF", 1, 100]} position={[0, -0.5, 7]} />
      )}
      <mesh
        scale={0.006}
        rotation={[0, 0, 0]}
        geometry={nodes["Sailboat_01_-_Default_0"].geometry}
        material={materials["01_-_Default"]}
        castShadow
      />
    </>
  );
}

useGLTF.preload("./assets/sailboat/scene.gltf");

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: vicente betoret ferrero (https://sketchfab.com/deathcow)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/3d-models/yate-38cd0b9138c64c4fa5fb125c5f6796f6
title: Yate
*/

export function Yate({ weather, props }) {
  const { nodes, materials } = useGLTF("./assets/yate/scene.gltf");
  return (
    <>
      {weather["skyState"] === "night" ? (
        <>
          <Light position={[0.7, 2.5, 3.8]} />
          <Light position={[-0.7, 2.5, 3.8]} />
        </>
      ) : (
        <pointLight args={["#FFFFFF", 1, 100]} position={[0, 0, 4]} />
      )}
      <group {...props} dispose={null} scale={0.09} position-z={1}>
        <primitive object={nodes._rootJoint} />
        <group rotation={[0, 0, -Math.PI]}>
          <mesh
            geometry={nodes.generic_item_wood3_0.geometry}
            material={materials.wood3}
          />
          <mesh
            geometry={nodes.generic_item_white3_0.geometry}
            material={materials.white3}
          />
          <mesh
            geometry={nodes.generic_item_wood2_0.geometry}
            material={materials.wood2}
          />
          <mesh
            geometry={nodes.generic_item_control_0.geometry}
            material={materials.control}
          />
          <mesh
            geometry={nodes.generic_item_white4_0.geometry}
            material={materials.white4}
          />
          <mesh
            geometry={nodes.generic_item_antenna_0.geometry}
            material={materials.antenna}
          />
          <mesh
            geometry={nodes.generic_item_Seats_0.geometry}
            material={materials.Seats}
          />
          <mesh
            geometry={nodes.generic_item_canopy_0.geometry}
            material={materials.canopy}
          />
          <mesh
            geometry={nodes.generic_item_windows1_0.geometry}
            material={materials.windows1}
          />
          <mesh
            geometry={nodes.generic_item_stairs_0.geometry}
            material={materials.stairs}
          />
          <mesh
            geometry={nodes.generic_item_windows2_0.geometry}
            material={materials.windows2}
          />
          <mesh
            geometry={nodes.generic_item_valve_0.geometry}
            material={materials.valve}
          />
          <mesh
            geometry={nodes.generic_item_white2_0.geometry}
            material={materials.white2}
          />
          <mesh
            geometry={nodes.generic_item_reflections_0.geometry}
            material={materials.reflections}
          />
          <mesh
            geometry={nodes.generic_item_metal_0.geometry}
            material={materials.metal}
          />
          <mesh
            geometry={nodes.generic_item_white1_0.geometry}
            material={materials.white1}
          />
          <mesh
            geometry={nodes.generic_item_door2_0.geometry}
            material={materials.door2}
          />
          <mesh
            geometry={nodes.generic_item_windows3_0.geometry}
            material={materials.windows3}
          />
          <mesh
            geometry={nodes.generic_item_hatch_0.geometry}
            material={materials.hatch}
          />
          <mesh
            geometry={nodes.generic_item_door1_0.geometry}
            material={materials.door1}
          />
          <mesh
            geometry={nodes.generic_item_lifebuoy_0.geometry}
            material={materials.lifebuoy}
          />
          <mesh
            geometry={nodes.generic_item_parket_0.geometry}
            material={materials.parket}
          />
          <mesh
            geometry={nodes.generic_item_wood_0.geometry}
            material={materials.wood}
          />
          <mesh
            geometry={nodes.generic_item_metal2_0.geometry}
            material={materials.metal2}
          />
        </group>
      </group>
    </>
  );
}

useGLTF.preload("./assets/yate/scene.gltf");

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: milamila (https://sketchfab.com/milamila)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/3d-models/boat-bd6166ae8e294bd4a7d4e46be7f80f5d
title: Boat
*/

export function RaceBoat(props) {
  const { nodes, materials } = useGLTF("./assets/boat/scene.gltf");
  return (
    <group
      {...props}
      dispose={null}
      scale={0.06}
      rotation={[Math.PI / 2, Math.PI, 0]}
    >
      <mesh
        geometry={nodes.polySurface67_CABIN_0.geometry}
        material={materials.CABIN}
      />
      <mesh
        geometry={nodes.polySurface67_GLASS_0.geometry}
        material={materials.GLASS}
      />
      <mesh
        geometry={nodes.polySurface70_CABIN_0.geometry}
        material={materials.CABIN}
      />
      <mesh
        geometry={nodes.polySurface71_CABIN_0.geometry}
        material={materials.CABIN}
      />
      <mesh
        geometry={nodes.polySurface72_CABIN_0.geometry}
        material={materials.CABIN}
      />
      <mesh
        geometry={nodes.polySurface73_CABIN_0.geometry}
        material={materials.CABIN}
      />
      <group scale={[-1, 1, 1]}>
        <mesh
          geometry={nodes.polySurface76_CABIN_0.geometry}
          material={materials.CABIN}
          scale={[-1, 1, 1]}
        />
      </group>
      <mesh
        geometry={nodes.polySurface82_CABIN_0.geometry}
        material={materials.CABIN}
      />
      <group scale={[-1, 1, 1]}>
        <mesh
          geometry={nodes.polySurface83_CABIN_0.geometry}
          material={materials.CABIN}
          scale={[-1, 1, 1]}
        />
      </group>
      <mesh
        geometry={nodes.pCylinder57_BoatBody_0.geometry}
        material={materials.BoatBody}
      />
      <mesh
        geometry={nodes.polySurface84_CABIN_0.geometry}
        material={materials.CABIN}
      />
      <mesh
        geometry={nodes.polySurface85_CABIN_0.geometry}
        material={materials.CABIN}
      />
      <mesh
        geometry={nodes.polySurface86_CABIN_0.geometry}
        material={materials.CABIN}
      />
      <mesh
        geometry={nodes.polySurface87_CABIN_0.geometry}
        material={materials.CABIN}
      />
    </group>
  );
}

useGLTF.preload("./assets/boat/scene.gltf");
